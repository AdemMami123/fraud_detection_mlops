% Chapter 5: Deployment and Web Application

\section{Introduction}

This chapter presents the deployment architecture of the fraud detection system. We detail the REST API developed with FastAPI, the user interface built with Next.js, and containerization with Docker.

\section{Overall System Architecture}

\subsection{Overview}

The fraud detection system consists of several interconnected components:

\begin{figure}[h]
    \centering
    \fbox{\parbox{0.95\textwidth}{\centering\vspace{5cm}\textit{[Placeholder: Complete architecture diagram showing: User $\rightarrow$ Next.js Frontend $\rightarrow$ FastAPI Backend $\rightarrow$ ML Model, with MLflow and DVC in support]}\vspace{5cm}}}
    \caption{Overall Architecture of the Fraud Detection System}
    \label{fig:system_architecture}
\end{figure}

\begin{description}
    \item[Frontend] Next.js web application for user interaction
    \item[Backend API] FastAPI service exposing prediction endpoints
    \item[ML Model] Trained Random Forest, loaded in memory at startup
    \item[Monitoring] Request logging and usage statistics
    \item[MLOps] DVC for pipeline, MLflow for tracking
\end{description}

\subsection{Data Flow}

\begin{enumerate}
    \item User submits a transaction via the web interface
    \item Frontend sends a POST request to the API
    \item API validates data and calls the model
    \item Model returns fraud probability
    \item API logs the request and sends response
    \item Frontend displays result to user
\end{enumerate}

\section{REST API with FastAPI}

\subsection{Why FastAPI}

FastAPI was chosen for its many advantages:

\begin{itemize}
    \item \textbf{Performance}: Based on Starlette and Uvicorn (ASGI), very fast
    \item \textbf{Validation}: Native Pydantic integration for data validation
    \item \textbf{Documentation}: Automatic Swagger/OpenAPI documentation generation
    \item \textbf{Type Hints}: Uses Python type annotations
    \item \textbf{Async Support}: Native support for asynchronous operations
\end{itemize}

\subsection{API Structure}

\begin{figure}[h]
    \centering
    \fbox{\parbox{0.8\textwidth}{\centering\vspace{3cm}\textit{[Placeholder: Screenshot of Swagger UI documentation automatically generated by FastAPI]}\vspace{3cm}}}
    \caption{API Swagger Documentation}
    \label{fig:swagger_ui}
\end{figure}

\subsection{Available Endpoints}

\begin{table}[h]
\centering
\begin{tabular}{|l|l|p{6cm}|}
\hline
\textbf{Method} & \textbf{Endpoint} & \textbf{Description} \\ \hline
GET & /health & Check API and model status \\ \hline
POST & /predict & Prediction for a single transaction \\ \hline
POST & /predict/batch & Batch predictions for multiple transactions \\ \hline
GET & /stats & API usage statistics \\ \hline
GET & / & General service information \\ \hline
\end{tabular}
\caption{Fraud Detection API Endpoints}
\label{tab:endpoints}
\end{table}

\subsection{Data Model}

Pydantic schemas ensure input/output validation:

\begin{verbatim}
class Transaction(BaseModel):
    Time: float
    Amount: float = Field(..., ge=0)
    V1: float
    V2: float
    # ... V3 to V28
    V28: float

class PredictionResponse(BaseModel):
    fraud_probability: float
    is_fraud: bool
    threshold: float
\end{verbatim}

\subsection{Error Handling}

The API implements robust error handling:

\begin{itemize}
    \item \textbf{400 Bad Request}: Invalid input data
    \item \textbf{500 Internal Server Error}: Error during prediction
    \item \textbf{503 Service Unavailable}: Model not loaded
\end{itemize}

\subsection{Logging and Monitoring}

Each prediction is logged in a CSV file for monitoring:

\begin{verbatim}
timestamp,time,amount,fraud_probability,is_fraud
2025-01-04T10:30:15,12345.0,149.99,0.1234,false
\end{verbatim}

\section{User Interface with Next.js}

\subsection{Technologies Used}

The user interface is built with a modern stack:

\begin{itemize}
    \item \textbf{Next.js 15}: React framework with server-side rendering
    \item \textbf{TypeScript}: Static typing for better maintainability
    \item \textbf{Tailwind CSS}: Utility-first CSS framework
    \item \textbf{Lucide React}: Modern icons
\end{itemize}

\subsection{Interface Features}

\begin{figure}[h]
    \centering
    \fbox{\parbox{0.95\textwidth}{\centering\vspace{5cm}\textit{[Placeholder: Screenshot of main web application interface showing transaction form and prediction result]}\vspace{5cm}}}
    \caption{Main Interface of Fraud Detection Application}
    \label{fig:webapp_main}
\end{figure}

\subsubsection{Single Prediction}

The main tab allows users to:
\begin{itemize}
    \item Manually enter transaction characteristics
    \item Use sample data (normal or fraudulent transaction)
    \item View result with probability and classification
\end{itemize}

\begin{figure}[h]
    \centering
    \fbox{\parbox{0.9\textwidth}{\centering\vspace{3cm}\textit{[Placeholder: Screenshot of transaction input form with Time, Amount, V1-V28 fields]}\vspace{3cm}}}
    \caption{Transaction Input Form}
    \label{fig:transaction_form}
\end{figure}

\subsubsection{Batch Prediction}

The Batch tab allows users to:
\begin{itemize}
    \item Upload a CSV file containing multiple transactions
    \item Run predictions on all transactions
    \item View results in a table
    \item Download results as CSV
\end{itemize}

\begin{figure}[h]
    \centering
    \fbox{\parbox{0.9\textwidth}{\centering\vspace{3cm}\textit{[Placeholder: Screenshot of batch prediction interface showing results table with statistics]}\vspace{3cm}}}
    \caption{Batch Prediction Interface}
    \label{fig:batch_prediction}
\end{figure}

\subsubsection{Statistics Dashboard}

The Statistics tab displays:
\begin{itemize}
    \item Total number of requests processed
    \item Average fraud probability
    \item Number and rate of detected frauds
\end{itemize}

\begin{figure}[h]
    \centering
    \fbox{\parbox{0.9\textwidth}{\centering\vspace{3cm}\textit{[Placeholder: Screenshot of statistics dashboard showing real-time KPIs]}\vspace{3cm}}}
    \caption{Statistics Dashboard}
    \label{fig:stats_dashboard}
\end{figure}

\subsection{Responsive Design}

The interface is fully responsive, adapting to different screen sizes:

\begin{figure}[h]
    \centering
    \fbox{\parbox{0.95\textwidth}{\centering\vspace{3cm}\textit{[Placeholder: Mockup showing application on desktop, tablet, and mobile]}\vspace{3cm}}}
    \caption{Responsive Application Design}
    \label{fig:responsive_design}
\end{figure}

\section{Containerization with Docker}

\subsection{Docker Architecture}

The system uses Docker to ensure consistent deployment:

\begin{figure}[h]
    \centering
    \fbox{\parbox{0.9\textwidth}{\centering\vspace{3cm}\textit{[Placeholder: Docker Compose diagram showing containers: fraud-detection-api and mlflow-server]}\vspace{3cm}}}
    \caption{Docker Compose Architecture}
    \label{fig:docker_architecture}
\end{figure}

\subsection{Dockerfile}

The Dockerfile uses a multi-stage build to optimize image size:

\begin{verbatim}
# Stage 1: Builder
FROM python:3.11-slim as builder
WORKDIR /app
COPY requirements.txt .
RUN pip install --user -r requirements.txt

# Stage 2: Production
FROM python:3.11-slim as production
COPY --from=builder /root/.local /root/.local
COPY api/ ./api/
COPY src/ ./src/
COPY models/ ./models/
COPY params.yaml .
CMD ["uvicorn", "api.main:app", 
     "--host", "0.0.0.0", "--port", "8000"]
\end{verbatim}

\subsection{Docker Compose}

The \texttt{docker-compose.yml} file orchestrates services:

\begin{verbatim}
services:
  api:
    build: .
    ports:
      - "8000:8000"
    volumes:
      - ./models:/app/models:ro
      - ./reports:/app/reports
    healthcheck:
      test: ["CMD", "curl", "-f", 
             "http://localhost:8000/health"]
      interval: 30s
\end{verbatim}

\subsection{Starting Services}

\begin{verbatim}
# Start the API
docker-compose up -d

# Check logs
docker-compose logs -f

# Stop services
docker-compose down
\end{verbatim}

\section{Cloud Deployment}

\subsection{Deployment Options}

The containerized system can be deployed on various cloud platforms:

\begin{table}[h]
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Platform} & \textbf{Service} & \textbf{Advantages} \\ \hline
Google Cloud & Cloud Run & Serverless, auto-scaling \\ \hline
AWS & ECS / Fargate & AWS ecosystem integration \\ \hline
Azure & Container Instances & Deployment simplicity \\ \hline
Kubernetes & GKE / EKS / AKS & Advanced orchestration \\ \hline
\end{tabular}
\caption{Cloud deployment options}
\label{tab:cloud_options}
\end{table}

\subsection{Example: Google Cloud Run Deployment}

\begin{verbatim}
# Build and push image
gcloud builds submit --tag gcr.io/PROJECT_ID/fraud-api

# Deploy to Cloud Run
gcloud run deploy fraud-detection-api \
  --image gcr.io/PROJECT_ID/fraud-api \
  --platform managed \
  --region europe-west1 \
  --allow-unauthenticated
\end{verbatim}

\section{Security}

\subsection{Implemented Measures}

\begin{itemize}
    \item \textbf{CORS}: Restrictive configuration of allowed origins
    \item \textbf{Validation}: Strict input validation via Pydantic
    \item \textbf{Rate Limiting}: Can be added via middleware
    \item \textbf{HTTPS}: Required in production
\end{itemize}

\subsection{Production Recommendations}

For production deployment, the following measures are recommended:

\begin{enumerate}
    \item API authentication (API Keys, OAuth2)
    \item Data encryption in transit (TLS)
    \item Monitoring and alerting (Prometheus, Grafana)
    \item Regular backup of models and data
\end{enumerate}

\section{Summary}

This chapter presented the complete deployment architecture of the fraud detection system. The FastAPI REST API offers performant and well-documented endpoints. The Next.js interface enables intuitive interaction with the system. Docker containerization ensures portability across different cloud environments. This architecture respects MLOps best practices and allows for future system evolution.
